/**
 * ActionsAIEnhancer.js
 *
 * Runs AFTER ActionsRulesEngine. Calls Claude only when:
 *   - Deal is 'risk' health status (most critical deals)
 *   - OR deal is high-value (>$100k) and rules produced < 3 actions
 *   - OR explicitly forced (ai_enhanced_generation = true AND deal is 'watch' or worse)
 *
 * Uses full deal context to generate ADDITIONAL actions that rules can't catch:
 *   - Nuanced email tone/sentiment signals
 *   - Implicit stakeholder dynamics
 *   - Competitive intelligence from file content
 *   - Personalised next-step recommendations
 *
 * AI is NOT called for healthy deals with sufficient rule-based actions.
 * This keeps AI cost proportional to deal risk.
 */

const { Anthropic } = require('@anthropic-ai/sdk');

const anthropic = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY });

class ActionsAIEnhancer {

  /**
   * Decide whether to call AI and, if so, generate additional actions.
   *
   * @param {object}  context         â€” from DealContextBuilder.build()
   * @param {Array}   rulesActions    â€” actions already generated by rules engine
   * @param {object}  actionConfig    â€” user's action_config row
   * @returns {Promise<Array>}         â€” additional AI-generated actions (may be empty)
   */
  static async enhance(context, rulesActions, actionConfig) {
    if (!this._shouldRunAI(context, rulesActions, actionConfig)) {
      return [];
    }

    try {
      const prompt   = this._buildPrompt(context, rulesActions);
      const rawText  = await this._callClaude(prompt);
      const aiActions = this._parseResponse(rawText, context);
      console.log(`ğŸ¤– AI Enhancer: generated ${aiActions.length} additional actions for deal ${context.deal.id}`);
      return aiActions;
    } catch (err) {
      console.error(`âŒ AI Enhancer error for deal ${context.deal.id}:`, err.message);
      return [];  // AI failure is non-fatal â€” rules actions still save
    }
  }

  // â”€â”€ Gate: when to spend AI budget â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  static _shouldRunAI(context, rulesActions, actionConfig) {
    // AI globally disabled
    if (!actionConfig?.ai_enhanced_generation) return false;
    if (actionConfig?.generation_mode === 'manual') return false;

    const { healthStatus, derived, deal } = context;

    // Always run for at-risk deals
    if (healthStatus === 'risk') return true;

    // Run for high-value deals in watch state with few rule actions
    if (derived.isHighValue && healthStatus === 'watch' && rulesActions.length < 4) return true;

    // Run for any watch deal with very few actions (rules couldn't find much)
    if (healthStatus === 'watch' && rulesActions.length < 2) return true;

    // Run when closing imminently and still at watch
    if (derived.closingImminently && healthStatus !== 'healthy') return true;

    return false;
  }

  // â”€â”€ Prompt construction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  static _buildPrompt(context, rulesActions) {
    const { deal, account, contacts, meetings, emails, files,
            healthBreakdown, healthScore, healthStatus, derived, playbookStageActions } = context;

    // Summarise rule actions already created so AI doesn't duplicate them
    const existingTitles = rulesActions.map(a => `- ${a.title}`).join('\n');

    // Recent emails (last 5, truncated for token budget)
    const emailSummary = emails.slice(0, 5).map(e =>
      `[${e.direction?.toUpperCase()}] ${new Date(e.sent_at).toLocaleDateString()} â€” ${e.subject || 'No subject'}: ${(e.body_preview || e.body || '').substring(0, 200)}`
    ).join('\n');

    // Recent meetings
    const meetingSummary = meetings.slice(0, 3).map(m =>
      `${new Date(m.start_time).toLocaleDateString()} â€” ${m.title || 'Meeting'} (${m.status}): ${(m.notes || m.description || 'No notes').substring(0, 150)}`
    ).join('\n');

    // Files
    const fileSummary = files.slice(0, 5).map(f =>
      `${f.file_name} (${f.category || 'unknown'}, ${f.processing_status})${f.ai_summary ? ': ' + f.ai_summary.substring(0, 150) : ''}`
    ).join('\n');

    // Health param summary â€” focus on unknowns and confirmed negatives
    const paramSummary = healthBreakdown?.params
      ? Object.entries(healthBreakdown.params)
          .filter(([, p]) => p.state === 'unknown' || (p.state === 'confirmed' && (p.impact || 0) < 0))
          .map(([k, p]) => `${k} (${p.label}): ${p.state}${p.evidence ? ' â€” ' + p.evidence.substring(0, 120) : ''}`)
          .join('\n')
      : 'No health breakdown available';

    // Contacts
    const contactSummary = contacts.slice(0, 5).map(c =>
      `${c.first_name} ${c.last_name} â€” ${c.title || 'Unknown title'} (${c.role_type || 'unknown role'})`
    ).join('\n');

    // Playbook actions not yet covered by rules
    const uncoveredPlaybook = (playbookStageActions || [])
      .filter(pa => !rulesActions.some(ra => ra.title.toLowerCase().includes(pa.toLowerCase().substring(0, 20))))
      .join('\n- ');

    return `You are a B2B sales strategy AI. Analyze this deal and generate ADDITIONAL actions that a sales rep should take RIGHT NOW to move the deal forward and protect the close date.

## DEAL
Name: ${deal.name}
Stage: ${deal.stage}
Value: $${parseFloat(deal.value || 0).toLocaleString()}
Close date: ${deal.close_date ? new Date(deal.close_date).toLocaleDateString() : 'Not set'}
Days until close: ${derived.daysUntilClose ?? 'Unknown'}
Health: ${healthStatus?.toUpperCase()} (score: ${healthScore ?? 'N/A'}/100)
Days in current stage: ${derived.daysInStage}

## ACCOUNT
${account ? `${account.name} â€” ${account.industry || 'Unknown industry'}, ${account.size || ''} employees` : 'No account data'}

## CONTACTS (${contacts.length} total)
${contactSummary || 'None'}

## RECENT EMAILS
${emailSummary || 'No emails'}

## RECENT MEETINGS
${meetingSummary || 'No meetings'}

## FILES
${fileSummary || 'No files'}

## HEALTH SCORE GAPS (params that are unknown or confirmed negative)
${paramSummary}

## PLAYBOOK ACTIONS FOR THIS STAGE (not yet covered)
${uncoveredPlaybook ? `- ${uncoveredPlaybook}` : 'All playbook actions are covered'}

## ACTIONS ALREADY GENERATED BY RULES ENGINE (do NOT duplicate these)
${existingTitles || 'None yet'}

---

Generate 2-5 ADDITIONAL specific, actionable next steps that the rules engine missed. Focus on:
1. Nuanced relationship or stakeholder dynamics visible in the emails/meetings
2. Competitive intelligence or risk signals from the content
3. Gaps in the health score that need creative resolution
4. Timing-sensitive actions given the close date

Return ONLY a JSON array. No markdown. No preamble. Each item:
{
  "title": "Specific action title (max 80 chars)",
  "description": "Why this action matters now (1-2 sentences)",
  "action_type": "email_send|meeting_schedule|document_prep|task_complete|follow_up",
  "priority": "high|medium|low",
  "due_days": 0-7,
  "suggested_action": "Specific how-to (1-2 sentences)",
  "confidence": 0.0-1.0,
  "reasoning": "What signal triggered this (1 sentence)"
}`;
  }

  // â”€â”€ Claude API call â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  static async _callClaude(prompt) {
    const message = await anthropic.messages.create({
      model:      'claude-haiku-4-5-20251001',  // Haiku for cost efficiency
      max_tokens: 1500,
      messages:   [{ role: 'user', content: prompt }],
    });
    return message.content[0]?.text || '[]';
  }

  // â”€â”€ Parse + normalise AI response â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  static _parseResponse(rawText, context) {
    try {
      let cleaned = rawText.trim()
        .replace(/```json\n?/gi, '')
        .replace(/```\n?/g, '');

      const start = cleaned.indexOf('[');
      const end   = cleaned.lastIndexOf(']');
      if (start === -1 || end === -1) return [];

      cleaned = cleaned.substring(start, end + 1);
      const parsed = JSON.parse(cleaned);
      if (!Array.isArray(parsed)) return [];

      return parsed
        .filter(a => a.title && a.action_type && a.priority)
        .slice(0, 5)
        .map(a => {
          const due_date = new Date();
          due_date.setDate(due_date.getDate() + (parseInt(a.due_days) || 1));
          return {
            title:           a.title.substring(0, 255),
            description:     a.description || '',
            action_type:     a.action_type,
            type:            a.action_type,
            priority:        ['high','medium','low'].includes(a.priority) ? a.priority : 'medium',
            due_date,
            deal_id:         context.deal.id,
            contact_id:      null,
            account_id:      context.deal.account_id,
            suggested_action: a.suggested_action || null,
            context:         a.reasoning || null,
            source:          'ai_generated',
            source_rule:     'ai_enhancer',
            metadata:        JSON.stringify({ confidence: a.confidence, reasoning: a.reasoning }),
          };
        });
    } catch (err) {
      console.error('âŒ AI Enhancer: failed to parse response:', err.message);
      return [];
    }
  }
}

module.exports = ActionsAIEnhancer;
